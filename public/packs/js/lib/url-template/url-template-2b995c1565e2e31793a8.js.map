{"version":3,"file":"js/lib/url-template/url-template-2b995c1565e2e31793a8.js","sources":["webpack:///webpack/bootstrap","webpack:///./app/javascript/packs/lib/url-template/url-template.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/packs/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./app/javascript/packs/lib/url-template/url-template.js\");\n","/*\n UriTemplates Template Processor - Version: @VERSION - Dated: @DATE\n (c) marc.portier@gmail.com - 2011-2012\n Licensed under APLv2 (http://opensource.org/licenses/Apache-2.0)\n */\n\n;\nvar uritemplate = (function() {\n\n// Below are the functions we originally used from jQuery.\n// The implementations below are often more naive then what is inside jquery, but they suffice for our needs.\n\n    function isFunction(fn) {\n        return typeof fn == 'function';\n    }\n\n    function isEmptyObject (obj) {\n        for(var name in obj){\n            return false;\n        }\n        return true;\n    }\n\n    function extend(base, newprops) {\n        for (var name in newprops) {\n            base[name] = newprops[name];\n        }\n        return base;\n    }\n\n    /**\n     * Create a runtime cache around retrieved values from the context.\n     * This allows for dynamic (function) results to be kept the same for multiple\n     * occuring expansions within one template.\n     * Note: Uses key-value tupples to be able to cache null values as well.\n     */\n        //TODO move this into prep-processing\n    function CachingContext(context) {\n        this.raw = context;\n        this.cache = {};\n    }\n    CachingContext.prototype.get = function(key) {\n        var val = this.lookupRaw(key);\n        var result = val;\n\n        if (isFunction(val)) { // check function-result-cache\n            var tupple = this.cache[key];\n            if (tupple !== null && tupple !== undefined) {\n                result = tupple.val;\n            } else {\n                result = val(this.raw);\n                this.cache[key] = {key: key, val: result};\n                // NOTE: by storing tupples we make sure a null return is validly consistent too in expansions\n            }\n        }\n        return result;\n    };\n\n    CachingContext.prototype.lookupRaw = function(key) {\n        return CachingContext.lookup(this, this.raw, key);\n    };\n\n    CachingContext.lookup = function(me, context, key) {\n        var result = context[key];\n        if (result !== undefined) {\n            return result;\n        } else {\n            var keyparts = key.split('.');\n            var i = 0, keysplits = keyparts.length - 1;\n            for (i = 0; i<keysplits; i++) {\n                var leadKey = keyparts.slice(0, keysplits - i).join('.');\n                var trailKey = keyparts.slice(-i-1).join('.');\n                var leadContext = context[leadKey];\n                if (leadContext !== undefined) {\n                    return CachingContext.lookup(me, leadContext, trailKey);\n                }\n            }\n            return undefined;\n        }\n    };\n\n\n    function UriTemplate(set) {\n        this.set = set;\n    }\n\n    UriTemplate.prototype.expand = function(context) {\n        var cache = new CachingContext(context);\n        var res = \"\";\n        var i = 0, cnt = this.set.length;\n        for (i = 0; i<cnt; i++ ) {\n            res += this.set[i].expand(cache);\n        }\n        return res;\n    };\n\n//TODO: change since draft-0.6 about characters in literals\n    /* extract:\n     The characters outside of expressions in a URI Template string are intended to be copied literally to the URI-reference if the character is allowed in a URI (reserved / unreserved / pct-encoded) or, if not allowed, copied to the URI-reference in its UTF-8 pct-encoded form.\n     */\n    function Literal(txt ) {\n        this.txt = txt;\n    }\n\n    Literal.prototype.expand = function() {\n        return this.txt;\n    };\n\n\n\n    var RESERVEDCHARS_RE = new RegExp(\"[:/?#\\\\[\\\\]@!$&()*+,;=']\",\"g\");\n    function encodeNormal(val) {\n        return encodeURIComponent(val).replace(RESERVEDCHARS_RE, function(s) {return escape(s);} );\n    }\n\n//var SELECTEDCHARS_RE = new RegExp(\"[]\",\"g\");\n    function encodeReserved(val) {\n        //return encodeURI(val).replace(SELECTEDCHARS_RE, function(s) {return escape(s)} );\n        return encodeURI(val); // no need for additional replace if selected-chars is empty\n    }\n\n\n    function addUnNamed(name, key, val) {\n        return key + (key.length > 0 ? \"=\" : \"\") + val;\n    }\n\n    function addNamed(name, key, val, noName) {\n        noName = noName || false;\n        if (noName) { name = \"\"; }\n\n        if (!key || key.length === 0)  {\n            key = name;\n        }\n        return key + (key.length > 0 ? \"=\" : \"\") + val;\n    }\n\n    function addLabeled(name, key, val, noName) {\n        noName = noName || false;\n        if (noName) { name = \"\"; }\n\n        if (!key || key.length === 0)  {\n            key = name;\n        }\n        return key + (key.length > 0 && val ? \"=\" : \"\") + val;\n    }\n\n\n    var simpleConf = {\n        prefix : \"\",     joiner : \",\",     encode : encodeNormal,    builder : addUnNamed\n    };\n    var reservedConf = {\n        prefix : \"\",     joiner : \",\",     encode : encodeReserved,  builder : addUnNamed\n    };\n    var fragmentConf = {\n        prefix : \"#\",    joiner : \",\",     encode : encodeReserved,  builder : addUnNamed\n    };\n    var pathParamConf = {\n        prefix : \";\",    joiner : \";\",     encode : encodeNormal,    builder : addLabeled\n    };\n    var formParamConf = {\n        prefix : \"?\",    joiner : \"&\",     encode : encodeNormal,    builder : addNamed\n    };\n    var formContinueConf = {\n        prefix : \"&\",    joiner : \"&\",     encode : encodeNormal,    builder : addNamed\n    };\n    var pathHierarchyConf = {\n        prefix : \"/\",    joiner : \"/\",     encode : encodeNormal,    builder : addUnNamed\n    };\n    var labelConf = {\n        prefix : \".\",    joiner : \".\",     encode : encodeNormal,    builder : addUnNamed\n    };\n\n\n    function Expression(conf, vars ) {\n        extend(this, conf);\n        this.vars = vars;\n    }\n\n    Expression.build = function(ops, vars) {\n        var conf;\n        switch(ops) {\n            case ''  : conf = simpleConf; break;\n            case '+' : conf = reservedConf; break;\n            case '#' : conf = fragmentConf; break;\n            case ';' : conf = pathParamConf; break;\n            case '?' : conf = formParamConf; break;\n            case '&' : conf = formContinueConf; break;\n            case '/' : conf = pathHierarchyConf; break;\n            case '.' : conf = labelConf; break;\n            default  : throw \"Unexpected operator: '\"+ops+\"'\";\n        }\n        return new Expression(conf, vars);\n    };\n\n    Expression.prototype.expand = function(context) {\n        var joiner = this.prefix;\n        var nextjoiner = this.joiner;\n        var buildSegment = this.builder;\n        var res = \"\";\n        var i = 0, cnt = this.vars.length;\n\n        for (i = 0 ; i< cnt; i++) {\n            var varspec = this.vars[i];\n            varspec.addValues(context, this.encode, function(key, val, noName) {\n                var segm = buildSegment(varspec.name, key, val, noName);\n                if (segm !== null && segm !== undefined) {\n                    res += joiner + segm;\n                    joiner = nextjoiner;\n                }\n            });\n        }\n        return res;\n    };\n\n\n\n    var UNBOUND = {};\n\n    /**\n     * Helper class to help grow a string of (possibly encoded) parts until limit is reached\n     */\n    function Buffer(limit) {\n        this.str = \"\";\n        if (limit === UNBOUND) {\n            this.appender = Buffer.UnboundAppend;\n        } else {\n            this.len = 0;\n            this.limit = limit;\n            this.appender = Buffer.BoundAppend;\n        }\n    }\n\n    Buffer.prototype.append = function(part, encoder) {\n        return this.appender(this, part, encoder);\n    };\n\n    Buffer.UnboundAppend = function(me, part, encoder) {\n        part = encoder ? encoder(part) : part;\n        me.str += part;\n        return me;\n    };\n\n    Buffer.BoundAppend = function(me, part, encoder) {\n        part = part.substring(0, me.limit - me.len);\n        me.len += part.length;\n\n        part = encoder ? encoder(part) : part;\n        me.str += part;\n        return me;\n    };\n\n\n    function arrayToString(arr, encoder, maxLength) {\n        var buffer = new Buffer(maxLength);\n        var joiner = \"\";\n\n        var i = 0, cnt = arr.length;\n        for (i=0; i<cnt; i++) {\n            if (arr[i] !== null && arr[i] !== undefined) {\n                buffer.append(joiner).append(arr[i], encoder);\n                joiner = \",\";\n            }\n        }\n        return buffer.str;\n    }\n\n    function objectToString(obj, encoder, maxLength) {\n        var buffer = new Buffer(maxLength);\n        var joiner = \"\";\n        var k;\n\n        for (k in obj) {\n            if (obj.hasOwnProperty(k) ) {\n                if (obj[k] !== null && obj[k] !== undefined) {\n                    buffer.append(joiner + k + ',').append(obj[k], encoder);\n                    joiner = \",\";\n                }\n            }\n        }\n        return buffer.str;\n    }\n\n\n    function simpleValueHandler(me, val, valprops, encoder, adder) {\n        var result;\n\n        if (valprops.isArr) {\n            result = arrayToString(val, encoder, me.maxLength);\n        } else if (valprops.isObj) {\n            result = objectToString(val, encoder, me.maxLength);\n        } else {\n            var buffer = new Buffer(me.maxLength);\n            result = buffer.append(val, encoder).str;\n        }\n\n        adder(\"\", result);\n    }\n\n    function explodeValueHandler(me, val, valprops, encoder, adder) {\n        if (valprops.isArr) {\n            var i = 0, cnt = val.length;\n            for (i = 0; i<cnt; i++) {\n                adder(\"\", encoder(val[i]) );\n            }\n        } else if (valprops.isObj) {\n            var k;\n            for (k in val) {\n                if (val.hasOwnProperty(k)) {\n                    adder(k, encoder(val[k]) );\n                }\n            }\n        } else { // explode-requested, but single value\n            adder(\"\", encoder(val));\n        }\n    }\n\n    function valueProperties(val) {\n        var isArr = false;\n        var isObj = false;\n        var isUndef = true;  //note: \"\" is empty but not undef\n\n        if (val !== null && val !== undefined) {\n            isArr = (val.constructor === Array);\n            isObj = (val.constructor === Object);\n            isUndef = (isArr && val.length === 0) || (isObj && isEmptyObject(val));\n        }\n\n        return {isArr: isArr, isObj: isObj, isUndef: isUndef};\n    }\n\n\n    function VarSpec (name, vhfn, nums) {\n        this.name = unescape(name);\n        this.valueHandler = vhfn;\n        this.maxLength = nums;\n    }\n\n\n    VarSpec.build = function(name, expl, part, nums) {\n        var valueHandler, valueModifier;\n\n        if (!!expl) { //interprete as boolean\n            valueHandler = explodeValueHandler;\n        } else {\n            valueHandler = simpleValueHandler;\n        }\n\n        if (!part) {\n            nums = UNBOUND;\n        }\n\n        return new VarSpec(name, valueHandler, nums);\n    };\n\n\n    VarSpec.prototype.addValues = function(context, encoder, adder) {\n        var val = context.get(this.name);\n        var valprops = valueProperties(val);\n        if (valprops.isUndef) { return; } // ignore empty values\n        this.valueHandler(this, val, valprops, encoder, adder);\n    };\n\n\n\n//----------------------------------------------parsing logic\n// How each varspec should look like\n    var VARSPEC_RE=/([^*:]*)((\\*)|(:)([0-9]+))?/;\n\n    var match2varspec = function(m) {\n        var name = m[1];\n        var expl = m[3];\n        var part = m[4];\n        var nums = parseInt(m[5], 10);\n\n        return VarSpec.build(name, expl, part, nums);\n    };\n\n\n// Splitting varspecs in list with:\n    var LISTSEP=\",\";\n\n// How each template should look like\n    var TEMPL_RE=/(\\{([+#.;?&\\/])?(([^.*:,{}|@!=$()][^*:,{}$()]*)(\\*|:([0-9]+))?(,([^.*:,{}][^*:,{}]*)(\\*|:([0-9]+))?)*)\\})/g;\n// Note: reserved operators: |!@ are left out of the regexp in order to make those templates degrade into literals\n// (as expected by the spec - see tests.html \"reserved operators\")\n\n\n    var match2expression = function(m) {\n        var expr = m[0];\n        var ops = m[2] || '';\n        var vars = m[3].split(LISTSEP);\n        var i = 0, len = vars.length;\n        for (i = 0; i<len; i++) {\n            var match;\n            if ( (match = vars[i].match(VARSPEC_RE)) === null) {\n                throw \"unexpected parse error in varspec: \" + vars[i];\n            }\n            vars[i] = match2varspec(match);\n        }\n\n        return Expression.build(ops, vars);\n    };\n\n\n    var pushLiteralSubstr = function(set, src, from, to) {\n        if (from < to) {\n            var literal = src.substr(from, to - from);\n            set.push(new Literal(literal));\n        }\n    };\n\n    var parse = function(str) {\n        var lastpos = 0;\n        var comp = [];\n\n        var match;\n        var pattern = TEMPL_RE;\n        pattern.lastIndex = 0; // just to be sure\n        while ((match = pattern.exec(str)) !== null) {\n            var newpos = match.index;\n            pushLiteralSubstr(comp, str, lastpos, newpos);\n\n            comp.push(match2expression(match));\n            lastpos = pattern.lastIndex;\n        }\n        pushLiteralSubstr(comp, str, lastpos, str.length);\n\n        return new UriTemplate(comp);\n    };\n\n\n//-------------------------------------------comments and ideas\n\n//TODO: consider building cache of previously parsed uris or even parsed expressions?\n\n    return parse;\n\n}());\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AADA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AATA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AADA;AACA;AAKA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAKA;AACA;AACA;AAAA;AAEA;;;;A","sourceRoot":""}